<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>夏令营面试准备 | Endorphin's Blog</title><meta name="author" content="Endorphin"><meta name="copyright" content="Endorphin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="计算机组成原理总线是什么？总线是一组功能部件之间分时共享的公共信息传送线路。 分时、共享是它的两大特点。 分时是指同一时刻只能有一个部件在总线上传输数据。 总线分类：片内总线、系统总线（数据总线、控制总线、地址总线）、通信总线。 总线通信方式：同步通信、异步通信、半同步通信、分离式通信。 总线特性： （1）机械特性是指总线在机械连接方式上的一些性能，如插头与插座适用的标准，尺寸、形状、引脚个数以及">
<meta property="og:type" content="article">
<meta property="og:title" content="夏令营面试准备">
<meta property="og:url" content="http://example.com/2024/07/01/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E9%9D%A2%E7%BB%8F/index.html">
<meta property="og:site_name" content="Endorphin's Blog">
<meta property="og:description" content="计算机组成原理总线是什么？总线是一组功能部件之间分时共享的公共信息传送线路。 分时、共享是它的两大特点。 分时是指同一时刻只能有一个部件在总线上传输数据。 总线分类：片内总线、系统总线（数据总线、控制总线、地址总线）、通信总线。 总线通信方式：同步通信、异步通信、半同步通信、分离式通信。 总线特性： （1）机械特性是指总线在机械连接方式上的一些性能，如插头与插座适用的标准，尺寸、形状、引脚个数以及">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://tse4-mm.cn.bing.net/th/id/OIP-C.WRUHUqRfulfxFQ8Z3GihKQAAAA?w=202&amp;h=202&amp;c=7&amp;r=0&amp;o=5&amp;dpr=1.3&amp;pid=1.7">
<meta property="article:published_time" content="2024-06-30T16:00:00.000Z">
<meta property="article:modified_time" content="2024-07-03T12:48:49.272Z">
<meta property="article:author" content="Endorphin">
<meta property="article:tag" content="面试">
<meta property="article:tag" content="夏令营">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tse4-mm.cn.bing.net/th/id/OIP-C.WRUHUqRfulfxFQ8Z3GihKQAAAA?w=202&amp;h=202&amp;c=7&amp;r=0&amp;o=5&amp;dpr=1.3&amp;pid=1.7"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/07/01/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E9%9D%A2%E7%BB%8F/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '夏令营面试准备',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-07-03 20:48:49'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/modify.css"><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://tse4-mm.cn.bing.net/th/id/OIP-C.WRUHUqRfulfxFQ8Z3GihKQAAAA?w=202&amp;h=202&amp;c=7&amp;r=0&amp;o=5&amp;dpr=1.3&amp;pid=1.7" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Endorphin's Blog"><span class="site-name">Endorphin's Blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">夏令营面试准备</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-06-30T16:00:00.000Z" title="发表于 2024-07-01 00:00:00">2024-07-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-07-03T12:48:49.272Z" title="更新于 2024-07-03 20:48:49">2024-07-03</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="夏令营面试准备"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h1><h2 id="总线是什么？"><a href="#总线是什么？" class="headerlink" title="总线是什么？"></a>总线是什么？</h2><p>总线是一组功能部件之间分时共享的公共信息传送线路。 分时、共享是它的两大特点。</p>
<p>分时是指同一时刻只能有一个部件在总线上传输数据。</p>
<p>总线分类：片内总线、系统总线（数据总线、控制总线、地址总线）、通信总线。</p>
<p>总线通信方式：同步通信、异步通信、半同步通信、分离式通信。</p>
<p>总线特性：</p>
<p>（1）机械特性是指总线在机械连接方式上的一些性能，如插头与插座适用的标准，尺寸、形状、引脚个数以及排列顺序。</p>
<p>（2）电气特性是指总线的每一根传输线上信号的传递方向和有效的电平范围。通常规定由 CPU 发出的信号称为输出信号。如，地址总线属于单向输出线，数据总线属于双向传输线，它们都定义为高电平为 “1”，低电平为 “0”。</p>
<p>（3）功能特性是指总线中每根传输线的功能，如地址总线是用来指出地址码；数据总线用来传递数据。由此可见，各条线的功能不同。</p>
<p>（4）时间特性是指总线中的任一根线在什么时间内有效。每条总线上的各种信号互相存在一种有效时序的关系，因此，事件特性一般可用信号时序图来描述。</p>
<p>总线性能指标：</p>
<p>（1）总线宽度：通常是指数据总线的根数，用bit 表示，如8位、16位、32位、64位</p>
<p>（2）总线带宽：总线带宽可理解为总线的数据传输速率，即单位时间内总线上传输数据的位数，通常用每秒传输信息的字节数来衡量，单位可用 Bps 表示。</p>
<p>（3）时钟同步/异步：总线上的数据与时钟同步工作的总线称为同步总线，与始终不同步工作的总线称为异步总线。</p>
<p>（4）总线复用：一条信号线上分时传送两种信号。例如通常地址总线与数据总线在物理上是分开的两种总线，地址总线传输地址码，数据总线传输数据信息。为了提高总线的利用率，优化设计，特将地址总线和数据总线共用一组物理线路，在这组物理线路上分式传输地址信号和数据信号，即为总线的多路复用。</p>
<p>（5）信号线数：地址总线、数据总线和控制总线三种总线书的总和</p>
<p>（6）总线控制方式：包括突发工作、自动配置、仲裁方式、逻辑方式、计数方式等</p>
<p>（7）其他指标：如负载能力、电源电压、总线宽度能否扩展等</p>
<h2 id="什么是DMA？"><a href="#什么是DMA？" class="headerlink" title="什么是DMA？"></a>什么是DMA？</h2><p>在DMA出现之前，CPU与外设之间的数据传送方式有程序传送方式、中断传送方式。CPU是通过系统总线与其他部件连接并进行数据传输。</p>
<p>程序传送方式是指直接在程序控制下进行数据的输入/输出操作。分为无条件传送方式和查询(条件传送方式)两种。</p>
<p>微机系统中的一些简单的外设，如开关、继电器、数码管、发光二极管等，在它们工作时，可以认为输入设备已随时准备好向CPU提供数据，而输出设备也随时准备好接收CPU送来的数据，这样，在CPU需要同外设交换信息时，就能够用IN或OUT指令直接对这些外设进行输入/输出操作。由于在这种方式下CPU对外设进行输入/输出操作时无需考虑外设的状态，故称之为无条件传送方式。</p>
<p>查询传送也称为条件传送，是指在执行输入指令（IN）或输出指令（OUT）前，要先查询相应设备的状态，当输入设备处于准备好状态、输出设备处于空闲状态时，CPU才执行输入/输出指令与外设交换信息。为此，接口电路中既要有数据端口，还要有状态端口。</p>
<p>中断传送方式是指当外设需要与CPU进行信息交换时，由外设向CPU发出请求信号，使CPU暂停正在执行的程序，转而去执行数据输入/输出操作，待数据传送结束后，CPU再继续执行被暂停的程序。</p>
<p>无条件传送和查询传送，均由CPU控制数据传输，不同的是程序传送方式由CPU来查询外设状态，CPU处于主动地位，而外设处于被动地位。这就是常说的对外设的轮询，效率低。而中断传送方式则是外设主动向CPU发生请求，等候CPU处理，在没有发出请求时，CPU和外设都可以独立进行各自的工作。  需要进行断点和现场的保护和恢复，浪费了很多CPU的时间，适合少量数据的传送。</p>
<p>DMA的出现就是为了解决批量数据的输入/输出问题。DMA是指外部设备不通过CPU而直接与系统内存交换数据的接口技术。这样数据的传送速度就取决于存储器和外设的工作速度。DMA是CPU和外设之间数据传输的方式，外部设备发送DMA请求，CPU同意之后就让出总线控制权，DMA控制器接管总线控制权之后开始进行外部设备与内存之间的直接数据的，CPU不再作为中枢。比较适合大量数据的传输，跟中断相比减少了中断请求、相应、保存上下文（即环境）的时间，使得资源利用率以及吞吐量更大。</p>
<p>一个完整的DMA周期通常有DMA请求、DMA响应、数据传输、DMA结束四个阶段</p>
<p>DMA的数据传送分为预处理、数据传送和后处理3个阶段。</p>
<p>(1)预处理</p>
<p>由CPU完成一些必要的准备工作。首先，CPU执行几条I/O指令，用以测试I/O设备状态，向DMA控制器的有关寄存器置初值，设置传送方向、启动该设备等。然后，CPU继续执行原来的程序，直到I/O设备准备好发送的数据(输入情况)或接受的数据(输出情况)时，I/O设备向DMA控制器发送DMA请求，再由DMA控制器向CPU发送总线请求(统称为DMA请求)，用以传输数据。</p>
<p>(2)数据传送</p>
<p>DMA的数据传输可以以单字节(或字)为基本单位，对于以数据块为单位的传送(如银盘)，DMA占用总线后的数据输入和输出操作都是通过循环来实现。需要特别之处的是，这一循环也是由DMA控制器(而不是通过CPU执行程序)实现的，即数据传送阶段是完全由DMA(硬件)来控制的。</p>
<p>(3)后处理</p>
<p>DMA控制器向CPU发送中断请求，CPU执行中断服务程序做DMA结束处理，包括检验送入主存的数据是否正确，测试传送过程中是否出错(错误则转入诊断程序)和决定是否继续使用DMA传送其他数据块等。</p>
<h2 id="简述五级流水CPU"><a href="#简述五级流水CPU" class="headerlink" title="简述五级流水CPU"></a>简述五级流水CPU</h2><p>五级流水线指的是：取指、译码、执行、访存、写回五个操作。<br>（1）指令取指（Instruction Fetch）是指将指令从存储器中读取出来的过程。</p>
<p>（2）指令译码（Instruction Decode）是指将存储器中取出的指令进行翻译的过程。经过译码之后得到指令需要的操作数寄存器索引，可以使用此索引从通用寄存器组（Register File，Regfile）中将操作数读出。</p>
<p>（3）指令译码之后所需要进行的计算类型都已得知，并且已经从通用寄存器组中读取出了所需的操作数，那么接下来便进行指令执行（Instruction Execute）。指令执行是指对指令进行真正运算的过程。譬如，如果指令是一条加法运算指令，则对操作数进行加法操作；如果是减法运算指令，则进行减法操作。<br>在“执行”阶段的最常见部件为算术逻辑部件运算器（ALU），作为实施具体运算的硬件功能单元。</p>
<p>（4）存储器访问指令往往是指令集中最重要的指令类型之一，访存（Memory Access）是指存储器访问指令将数据从存储器中读出，或者写入存储器的过程。</p>
<p>（5）写回（Write-Back）是指将指令执行的结果写回通用寄存器组的过程。如果是普通运算指令，该结果值来自于“执行”阶段计算的结果；如果是存储器读指令，该结果来自于“访存”阶段从存储器中读取出来的数据。</p>
<h2 id="执行单条指令时单周期CPU和五级流水CPU谁更快，为什么？"><a href="#执行单条指令时单周期CPU和五级流水CPU谁更快，为什么？" class="headerlink" title="执行单条指令时单周期CPU和五级流水CPU谁更快，为什么？"></a>执行单条指令时单周期CPU和五级流水CPU谁更快，为什么？</h2><p>传统的单周期CPU是指指令在一个时钟周期（即时钟到来一次）内执行完成，包括所有的操作。但存在的问题是时钟周期的时间是固定的，所以时钟周期的时间应该是最长的指令所需要的时间，对于短指令，就会造成浪费。引入多周期就可以减少浪费的时间。</p>
<p>单周期CPU（是指在一个时钟周期内完成这五个阶段的处理）更快。因为五级流水CPU中每一个操作的流水时间是一样的，取的是这五步中的最大执行时间，那么就是最大操作时间 * 5。而单周期CPU就恰好能覆盖这条指令的执行时间，没有多余。</p>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="内部排序"><a href="#内部排序" class="headerlink" title="内部排序"></a>内部排序</h2><p>内部排序有：</p>
<p>（1）选择排序：每次从待排序区域选出最小的元素加入到已排序区域中。是不稳定的。时间复杂度$O(n^2)$</p>
<p>（2）插入排序：简单插入、折半插入。每次把待排序区域第一个元素插入到已排序区域中合适的位置。是稳定的。时间复杂度$O(n^2)$</p>
<p>（3）希尔排序：对每一个子表进行直接插入排序，第一趟步长d，第二趟步长$\frac{d}{2}$……直到步长为1，此时就是简单插入排序。是不稳定的。时间复杂度$O(n^{1.3}—n^2)$</p>
<p>（4）冒泡排序：从前往后两两元素依次比较，较大的放后面，就像一个泡泡从前往后走。是稳定的。时间复杂度$O(n^2)$</p>
<p>（5）快速排序：选取一个$pivot$，通过两个指针$low$和$high$，从左右两边依次与$pivot$比较，比$pivot$小的放$pivot$左边，比$pivot$大的放$pivot$右边。这样$pivot$就找到了他自己的位置。接着再对$pivot$位置分割成的左右两个子数组递归使用快速排序。是不稳定的。时间复杂度$O(nlogn)$</p>
<p>（5）归并排序：先把数组一分二、二分四，一直分到长度为1（自身有序）的一个个子数组，然后再两两归并。是稳定的。时间复杂度$O(nlogn)$。</p>
<p>（6）基数排序：先比较个位，按照个位从大到小排个序；再比较十位，在个位的相对顺序的基础上按照十位的大小排序…..最后的结果就是有序的。是稳定的。时间复杂度$O(n*k)$</p>
<p>（7）堆排序：维护一个大根堆或者小根堆。依次把根输出并删除，然后重新维护，重复。是不稳定的。时间复杂度$O(nlogn)$。</p>
<h2 id="排序为什么要求稳定性？"><a href="#排序为什么要求稳定性？" class="headerlink" title="排序为什么要求稳定性？"></a>排序为什么要求稳定性？</h2><p>背景：“稳定”排序算法按顺序保存具有相同排序键的项目。假设我们有一个5个字母的单词列表：<br>peach、straw、apple、spork<br>如果我们<strong>只按每个单词的第一个字母对列表进行排序</strong>，那么稳定排序会产生：<br>apple、peach、straw、spork<br>在一个 不稳定 排序算法， straw 和 spork 可以互换，但在稳定的情况下，它们保持相同的相对位置。</p>
<p>举个例子，一个班的学生已经按照学号大小排好序了，我现在要求按照年龄从小到大再排个序，如果年龄相同的，必须按照学号从小到大的顺序排列。那么问题来了，你选择的年龄排序方法如果是不稳定的，是不是排序完了后年龄相同的一组学生学号就乱了，你就得把这组年龄相同的学生再按照学号拍一遍。如果是稳定的排序算法，我就只需要按照年龄排一遍就好了。</p>
<p>从一个键上排序，然后再从另一个键上排序，第一个键排序的结果可以为第二个键排序所用。要排序的内容是一个复杂对象的多个数字属性，且其原本的初始顺序存在意义，那么我们需要在二次排序的基础上保持原有排序的意义，才需要使用到稳定性的算法。</p>
<h2 id="胜者树"><a href="#胜者树" class="headerlink" title="胜者树"></a>胜者树</h2><p>就像锦标赛，小组赛，层层推优的机制</p>
<p>父亲节点存的是胜出的节点</p>
<h2 id="败者树"><a href="#败者树" class="headerlink" title="败者树"></a>败者树</h2><p>父亲节点记录的是失败的节点，但是向上推选的是胜出的节点</p>
<p>所以最终还需要额外的一个节点来记录比出的胜者（因为胜者不在节点里存着）</p>
<p>这么做的好处是，每次改变一个节点时，只需要沿着父结点一路向上比较到根节点即可；但胜者树则还需要和兄弟节点相比。</p>
<img src="/2024/07/01/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E9%9D%A2%E7%BB%8F/image-20240703102825733.png" class="" title="image-20240703102825733">

<h2 id="外部排序为什么不用多路归并？为什么用败者树不用胜者树？"><a href="#外部排序为什么不用多路归并？为什么用败者树不用胜者树？" class="headerlink" title="外部排序为什么不用多路归并？为什么用败者树不用胜者树？"></a>外部排序为什么不用多路归并？为什么用败者树不用胜者树？</h2><p>多路归并虽然能加快归并的效率，但是每次比较选择最值时随着路的增多困难程度也会增加，耗时也会增多。</p>
<p>为了减少每次判断最值时需要花费的时间和比较的次数，这才引入了胜者树和败者树的概念。</p>
<p>因为败者树某结点改变之后只需要跟它的父节点进行比较直至根节点即可，但是胜者树还要跟他的兄弟结点进行比较，编程不易实现。</p>
<h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p>对于任何节点，左子树都小于根，右子树都大于根。不允许存在值相同的元素</p>
<p>构建、插入、删除都基于搜索来实现</p>
<p>搜索：给一个节点，从根节点开始向下比较，比当前节点值大，就去跟当前结点的有孩子比；反之就跟当前结点左子树比。</p>
<p>插入：基于搜索，找到目标节点，且它左孩子（或右孩子）为空的位置，插入</p>
<p>删除：如果是删除叶子结点，直接删除即可；如果是删除只有左子树或只有右子树的节点，需要用该节点的子树替代它；如果是删除既有左子树又有右子树的节点，需要先找左子树中最大的节点（或右子树中最小的节点）来替代该节点，并删除那个子树中最大（或最小）的节点</p>
<p>构建：把各个节点依次插入，即可构建</p>
<h2 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h2><p>为了避免二叉搜索树中的极端情况，使得BST退化为链表，这才引入AVL树</p>
<p>定义：首先得是一颗二叉排序树，其次要满足树中每个节点的左子树深度－右子树深度（平衡因子）绝对值不超过1</p>
<p>插入、删除、构建、查找都是同BST一样的，只是每次插入删除后都需要检查是否失衡，如果失衡需要通过相应的操作——左旋和右旋两种操作来调整。</p>
<p>冲突的左孩变右孩，冲突的右孩变左孩</p>
<p>LL型：右旋失衡点</p>
<p>RR型：左旋失衡点</p>
<p>LR型：左旋失衡点左孩子，然后右旋失衡点</p>
<p>RL型：右旋失衡点右孩子，然后左旋失衡点</p>
<h2 id="AVL平衡树旋转，从一个状态插入、删除一个数时，最多旋转几次？"><a href="#AVL平衡树旋转，从一个状态插入、删除一个数时，最多旋转几次？" class="headerlink" title="AVL平衡树旋转，从一个状态插入、删除一个数时，最多旋转几次？"></a>AVL平衡树旋转，从一个状态插入、删除一个数时，最多旋转几次？</h2><p>插入一个数，最多旋转两次。LR型，或者RL型。</p>
<p>删除一个数，就不一定几次了，可能需要很多次。</p>
<img src="/2024/07/01/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E9%9D%A2%E7%BB%8F/image-20240702165933320.png" class="" title="image-20240702165933320">

<img src="/2024/07/01/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E9%9D%A2%E7%BB%8F/image-20240702170024156.png" class="" title="image-20240702170024156">

<p>与插入时不同，删除时需要依次对每个祖先检查并调整</p>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>也是对BST的一种平衡化策略，但是和AVL树不太一样</p>
<p>红黑树也是一颗BST</p>
<img src="/2024/07/01/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E9%9D%A2%E7%BB%8F/image-20240702171300596.png" class="" title="image-20240702171300596">

<p>最长路径不会超过最短路径的两倍，任意节点左右子树的高度相差不超过两倍</p>
<img src="/2024/07/01/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E9%9D%A2%E7%BB%8F/image-20240702173226921.png" class="" title="image-20240702173226921">

<p>这里的LL/RR/LR/RL的判断是看插入节点、其父亲节点和其爷爷节点三个节点的形态，旋转是对“爷爷节点”进行左旋或右旋，变色是对旋转点和旋转中心点变色</p>
<p>删除</p>
<img src="/2024/07/01/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E9%9D%A2%E7%BB%8F/image-20240703081507498.png" class="" title="image-20240703081507498">

<h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><img src="/2024/07/01/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E9%9D%A2%E7%BB%8F/image-20240703090750380.png" class="" title="image-20240703090750380">

<h2 id="B树（B-树）"><a href="#B树（B-树）" class="headerlink" title="B树（B-树）"></a>B树（B-树）</h2><p>多叉的平衡搜索树</p>
<img src="/2024/07/01/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E9%9D%A2%E7%BB%8F/image-20240703083556984.png" class="" title="image-20240703083556984">

<p>搜索：按照BST的策略进行搜索，在节点内部有多个值时，因为是有序的，所以可以是二分查找也可以是顺序查找；如果找到了空节点，也就是失败节点，说明不存在此节点元素</p>
<p>插入：也是按照BST的策略找到应该插入的位置，然后插入，如果插入后发生上溢出，就把此节点的中间元素向上推形成根节点，中间元素左右两边的元素分别组成一个节点当做根节点的左右孩子</p>
<p>删除：首先也是BST的逻辑，如果是非叶子节点元素，需要找直接前驱和直接后继，替换后，就转成了删除叶子节点元素</p>
<img src="/2024/07/01/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E9%9D%A2%E7%BB%8F/image-20240703090004533.png" class="" title="image-20240703090004533">

<h2 id="为什么有了平衡二叉树还会出现B-、B-、红黑树呢？"><a href="#为什么有了平衡二叉树还会出现B-、B-、红黑树呢？" class="headerlink" title="为什么有了平衡二叉树还会出现B-、B+、红黑树呢？"></a>为什么有了平衡二叉树还会出现B-、B+、红黑树呢？</h2><p>平衡二叉树是一种非常有用的数据结构，但它并不总是适合所有场景</p>
<p><strong>操作复杂度的平衡需求</strong>：平衡二叉树虽然保证了每个节点的左右子树高度差不超过1，但在高度不变的情况下，其查找、插入和删除操作的时间复杂度可能达到O(log n)。对于需要频繁插入和删除、或者需要支持范围查询的情况，B-树和B+树能够更好地平衡查询效率和插入删除效率。</p>
<p><strong>磁盘存储优化</strong>：B-树和B+树设计时考虑了磁盘I/O操作的效率。它们通过增大节点的容量和减少树的高度，从而减少磁盘I/O次数，更适合于大规模数据的存储和检索，特别是在数据库系统中广泛应用。</p>
<p><strong>范围查询优化</strong>：B+树相较于平衡二叉树，具有更好的范围查询性能。因为B+树内部的叶子节点形成了一个有序链表，能够快速地遍历范围内的数据。</p>
<p><strong>实际应用需求</strong>：红黑树则是一种特殊的平衡二叉搜索树，它在某些场景下比平衡二叉树更加高效，例如在C++的STL中的map和set实现中广泛应用，主要因为它的插入和删除操作更为简单，且具有较好的平衡性能。</p>
<p>综上所述，尽管平衡二叉树提供了良好的平衡性质，但不同的数据结构在不同的应用场景中可能会有更优的表现，因此B-树、B+树和红黑树等数据结构依然在实际中被广泛使用和研究。</p>
<h2 id="为什么数据库索引用B-树而不用B-树？"><a href="#为什么数据库索引用B-树而不用B-树？" class="headerlink" title="为什么数据库索引用B+树而不用B-树？"></a>为什么数据库索引用B+树而不用B-树？</h2><p>因为</p>
<p>（1）B-树如果要实现顺序查找，就只能通过中序遍历，需要在节点之间来回移动，效率较低；而B+树能通过类似链表的结构来实现高效的顺序查找。</p>
<p>（2）B-树中间节点存数据，而B+树中间节点存的是索引，在叶子结点存数据。他们的树都存储在外存中，每次读取花费时间相较于内存较长，B-树找一个数据可能需要多次访问外存，进行比较和查找；但B+树非叶子节点存的是索引，不需要在中间节点反复读取外存，所以大大加快了查询速率。</p>
<p>（3）与B-树相比，B+树还可以实现范围查找，能更好的满足数据库的需求。</p>
<h2 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h2><p>引入目的是为了方便查找节点的前驱和后继</p>
<p>利用二叉树中的空链域存放节点的前驱和后继</p>
<p>$ltag = 0$表示有左孩子，$lchild$存放的是左孩子；$ltag=1$表示无左孩子，$lchild$存放的是前驱</p>
<p>$rtag$同理</p>
<p>好处：时间复杂度$O(n)$，空间复杂度$O(1)$，不需要栈来实现递归</p>
<h2 id="哈夫曼树及哈夫曼编码"><a href="#哈夫曼树及哈夫曼编码" class="headerlink" title="哈夫曼树及哈夫曼编码"></a>哈夫曼树及哈夫曼编码</h2><p>哈夫曼编码能在不出现歧义的情况下使得编出来的码长度最短</p>
<p>思想是，使得出现次数最多的字符让他们编码长度最短</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>{</span></span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">    Type parent;</span><br><span class="line">    Type lchild;</span><br><span class="line">    Type rchild;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<img src="/2024/07/01/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E9%9D%A2%E7%BB%8F/image-20240703101657887.png" class="" title="image-20240703101657887">

<p>每次取出最小的两个节点，合并后再放入节点集合中，接着重复此操作</p>
<h2 id="二叉树，证明二度节点数与零度节点数的关系"><a href="#二叉树，证明二度节点数与零度节点数的关系" class="headerlink" title="二叉树，证明二度节点数与零度节点数的关系"></a>二叉树，证明二度节点数与零度节点数的关系</h2><p>边数目$n=n_0+n_1+n_2-1$;</p>
<p>度$m=0<em>n_0+1</em>n_1+2*n_2$;</p>
<p>边数等于度$m=n%$</p>
<p>所以$n_1+2n_2=n_0+n_1+n_2-1$</p>
<p>得到$n_0=n_2+1$;</p>
<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p>（1）$Prim$<br>从某点出发的最小生成树，如果想要任意点出发求出的最小生成树相同，那么必须满足该树中没有相同长度的边。$O(n^2)$，与边无关，适合稠密图。</p>
<p>（2）$Kruskal$<br>将边先进行排序，并用v去记录每个点的连通分量，每次选择与已选边的连通分量不同的且边长度最短的边。选择后要更改相应的连通分量一致。$O(eloge)$，与点无关，适合稀疏图。</p>
<h2 id="设计一个算法证明一个链是回文链，使得时间复杂度为O-n-空间复杂度为O-1"><a href="#设计一个算法证明一个链是回文链，使得时间复杂度为O-n-空间复杂度为O-1" class="headerlink" title="设计一个算法证明一个链是回文链，使得时间复杂度为O(n)空间复杂度为O(1)"></a>设计一个算法证明一个链是回文链，使得时间复杂度为O(n)空间复杂度为O(1)</h2><p><strong>找到链表的中间节点</strong>： 使用快慢指针法来找到链表的中间节点。快指针每次移动两步，慢指针每次移动一步。当快指针到达链表末尾时，慢指针正好在链表的中间位置。</p>
<p><strong>反转链表的后半部分</strong>： 从慢指针所在的位置开始，将链表的后半部分反转。</p>
<p><strong>比较链表的前半部分和反转后的后半部分</strong>： 从链表的头节点开始，同时从反转后的链表部分开始，逐个比较这两个部分的节点值。如果所有节点值都相同，则链表是回文的，否则不是。</p>
<h2 id="最短路径算法"><a href="#最短路径算法" class="headerlink" title="最短路径算法"></a>最短路径算法</h2><p>（1）$Dijkstra$算法</p>
<p>时间复杂度为$O(n^2)$，可以得到从一个节点出发到其他所有节点的最短路径。</p>
<p>需要：$visited[]、D[]、path[]、arcs[][];$</p>
<p>$visited$记录是否被访问；$D$存储最短路径长度；$path$存储最短路径；$arcs$[][]记录邻接矩阵表示各个节点之间的边的权重</p>
<p>应用：网络层协议中开放最短路径优先协议OSPF，计算最短路由用的是该算法。</p>
<img src="/2024/07/01/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E9%9D%A2%E7%BB%8F/image-20240703104548716.png" class="" title="image-20240703104548716">

<p>（2）$Floyd$算法</p>
<p>时间复杂度$O(n^3)$，可以得到任意两个结点之间的最短距离</p>
<p>依次将每个点作为中间点去做更新 </p>
<p>使用了动态规划的思想</p>
<p>需要：$D[]，path[][]$</p>
<p>$D$记录最短路径长度，$path$记录最短路径，存的是$path[i][j]$中$j$的前驱节点</p>
<img src="/2024/07/01/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E9%9D%A2%E7%BB%8F/image-20240703105908294.png" class="" title="image-20240703105908294">

<img src="/2024/07/01/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E9%9D%A2%E7%BB%8F/image-20240703110321911.png" class="" title="image-20240703110321911">




<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>一个有向无环图来代表一个工程，每条边代表一个活动</p>
<p>必须是有向无环图才有拓扑序，也正因如此，此算法可以用来判断图中有无环</p>
<p>每次都选入度为0的点，然后删除这个点和它的出边</p>
<p>在拓扑排序用于判断有向图是否存在环的实现中，通常需要以下几个变量：</p>
<p><code>indegree[]</code>：一个数组，用于记录每个结点的入度。</p>
<p><code>stack</code>：一个栈，用于临时保存拓扑排序过程中入度变为0的结点。</p>
<p><code>topo[]</code>：一个数组，用于保存拓扑排序后的结点序列。</p>
<p><code>m</code>：一个计数器，用于记录<code>topo</code>数组中结点的数目。</p>
<p><code>graph</code>：一个邻接表或邻接矩阵，用于表示有向图。</p>
<p>在实际实现中，可以使用以下步骤：</p>
<p>(1) 初始化<code>indegree[]</code>数组，遍历图的所有边，计算每个结点的入度。</p>
<p>(2) 将所有入度为0的结点入栈<code>stack</code>。</p>
<p>(3) 进入主循环，从栈中弹出一个结点，将其加入到<code>topo[]</code>中，并将计数器<code>m</code>加1。</p>
<p>(4) 遍历弹出结点的所有邻接结点，将这些邻接结点的入度减1，如果入度变为0，则将其入栈。</p>
<p>(5) 循环结束后，如果计数器<code>m</code>等于图中结点的数目，则说明图中没有环，否则存在环。</p>
<h2 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h2><img src="/2024/07/01/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E9%9D%A2%E7%BB%8F/image-20240703160235461.png" class="" title="image-20240703160235461">

<img src="/2024/07/01/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E9%9D%A2%E7%BB%8F/image-20240703160211254.png" class="" title="image-20240703160211254">

<h2 id="DFS-BFS"><a href="#DFS-BFS" class="headerlink" title="DFS/BFS"></a>DFS/BFS</h2><p>DFS：不撞南墙不回头，撞了南墙再回头。一条道走到黑，走不动了再回退。</p>
<p>BFS：层层扩散</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 50</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[MAX][MAX]; <span class="comment">// 存储边</span></span><br><span class="line"><span class="type">int</span> n, k; <span class="comment">// 存储顶点和边个数</span></span><br><span class="line"><span class="type">int</span> visited[MAX]; <span class="comment">// 是否已访问</span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; qu; <span class="comment">// 广搜队列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 深度优先遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> i)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (i &gt; n) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) { <span class="comment">// 相邻顶点未必按照自然数访问</span></span><br><span class="line">            <span class="keyword">if</span> (visited[j] == <span class="number">0</span> &amp;&amp; a[i][j] == <span class="number">1</span>) { <span class="comment">// 未被访问且从i到j有边</span></span><br><span class="line">                visited[j] = <span class="number">1</span>;</span><br><span class="line">                cout &lt;&lt; j &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(j); <span class="comment">// 不需要回溯</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 广度优先遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> i)</span> </span>{</span><br><span class="line">    qu.<span class="built_in">push</span>(i);</span><br><span class="line">    visited[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!qu.<span class="built_in">empty</span>()) {</span><br><span class="line">        <span class="type">int</span> t = qu.<span class="built_in">front</span>();</span><br><span class="line">        cout &lt;&lt; t &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        qu.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) { <span class="comment">// 相邻顶点全部进栈</span></span><br><span class="line">            <span class="keyword">if</span> (visited[j] == <span class="number">0</span> &amp;&amp; a[t][j] == <span class="number">1</span>) {</span><br><span class="line">                visited[j] = <span class="number">1</span>;</span><br><span class="line">                qu.<span class="built_in">push</span>(j);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cin &gt;&gt; k;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in">sizeof</span>(a)); <span class="comment">// 初始化数组</span></span><br><span class="line">    <span class="built_in">memset</span>(visited, <span class="number">0</span>, <span class="built_in">sizeof</span>(visited)); <span class="comment">// 初始化标记数组</span></span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入边之间信息, 默认顶点值为1~N</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++) {</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        a[x][y] = <span class="number">1</span>;</span><br><span class="line">        a[y][x] = <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"深搜："</span> &lt;&lt; endl;</span><br><span class="line">    visited[<span class="number">1</span>] = <span class="number">1</span>; <span class="comment">// 初始化第一个节点为已访问</span></span><br><span class="line">    cout &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>); <span class="comment">// 顶点1开始</span></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(visited, <span class="number">0</span>, <span class="built_in">sizeof</span>(visited)); <span class="comment">// 重新初始化标记数组</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"广搜："</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">bfs</span>(<span class="number">1</span>); <span class="comment">// 顶点1开始</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h2 id="如何编程判断一棵二叉树是完全二叉树"><a href="#如何编程判断一棵二叉树是完全二叉树" class="headerlink" title="如何编程判断一棵二叉树是完全二叉树"></a>如何编程判断一棵二叉树是完全二叉树</h2><p>用队列进行层次遍历。记录遍历的结点数目+每次pop()出一个结点之后都对其进行孩子的判断。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">p=<span class="built_in">pop</span>();</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">if</span>(p -&gt; lchild != null &amp;&amp; p -&gt; rchild != null)----&gt;<span class="function">then <span class="title">push</span><span class="params">(lchild)</span>，<span class="title">push</span><span class="params">(rchild)</span></span></span><br><span class="line"><span class="function"><span class="keyword">else</span> <span class="title">if</span><span class="params">(p-&gt;lchild==null)</span>---&gt;then <span class="keyword">return</span> <span class="literal">false</span></span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;rchild==null)---&gt; then <span class="built_in">push</span>(lchild); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">while</span>(!stack.<span class="built_in">empty</span>()){</span><br><span class="line">    stack.<span class="built_in">pop</span>();</span><br><span class="line">    count++;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(count==n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fa[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span>{</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++){</span><br><span class="line">        fa[i] = i;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(fa[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">find</span>(fa[x]);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//路径压缩</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(fa[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span>{</span><br><span class="line">		fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">        <span class="keyword">return</span> fa[x];</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span>{</span><br><span class="line">	fa[<span class="built_in">find</span>(i)] = <span class="built_in">find</span>(j);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h2><p>散列函数</p>
<p>冲突：开放地址法（线性探测、二次探测、伪随机探测）、链地址法</p>
<img src="/2024/07/01/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E9%9D%A2%E7%BB%8F/image-20240703111850259.png" class="" title="image-20240703111850259">

<h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><h2 id="时间复杂度、空间复杂度的计算"><a href="#时间复杂度、空间复杂度的计算" class="headerlink" title="时间复杂度、空间复杂度的计算"></a>时间复杂度、空间复杂度的计算</h2><p>O 表示的是数量级，即算法中语句频度$f(n)$的最高数量级。</p>
<p>递归通用计算时间复杂度的公式：</p>
<p>$T(n)=aT(n/b)+f(n)$; 前提：$a&gt;1,b&gt;1$</p>
<p>if $O(n^{log_ba})&gt;O(f(n))$  则：$O(T(n))=O(n^{log_ba})$;</p>
<p>if $O(n^{log_ba})==O(f(n))$  则：$O(T(n))=O(f(n)*(logn))$;</p>
<p>if $O(n^{log_ba})&lt;O(f(n))$  则：$O(T(n))=O(f(n))$;</p>
<p>空间复杂度是算法所需存储空间的量度。</p>
<p>递归是用到的栈也是空间。</p>
<h2 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h2><p>动态规划， <code>dp[i][j]</code>表示第0到<code>i</code>个物品任取、背包容量为<code>j</code>的最大重量</p>
<p>分支限界法</p>
<p>回溯法</p>
<h2 id="P问题-NP问题-NP完全问题"><a href="#P问题-NP问题-NP完全问题" class="headerlink" title="P问题 NP问题 NP完全问题"></a>P问题 NP问题 NP完全问题</h2><p>P问题、NP问题和NP完全问题是计算复杂性理论中的三个重要概念，用于描述算法问题的难易程度和解决这些问题所需的计算资源。</p>
<h3 id="P问题"><a href="#P问题" class="headerlink" title="P问题"></a>P问题</h3><p>P问题指的是那些可以在多项式时间内（即时间复杂度为多项式级别）通过确定性图灵机解决的问题。简单来说，如果存在一个算法能够在$O(n^k)$的时间内解决一个问题，其中$n$是输入规模，$k$是常数，则这个问题属于P类。</p>
<h3 id="NP问题"><a href="#NP问题" class="headerlink" title="NP问题"></a>NP问题</h3><p>NP问题指的是那些解可以在多项式时间内通过非确定性图灵机验证的问题。换句话说，如果给定一个候选解，我们可以在多项式时间内验证其是否为正确解，则这个问题属于NP类。</p>
<p>值得注意的是，NP问题不一定可以在多项式时间内通过确定性算法解决，但它们的解可以在多项式时间内验证。</p>
<h3 id="NP完全问题"><a href="#NP完全问题" class="headerlink" title="NP完全问题"></a>NP完全问题</h3><p>NP完全问题是NP问题中的一个子集，这些问题具有两个关键性质：</p>
<p>它们是NP问题。</p>
<p>每个NP问题都可以通过多项式时间归约转化为这些问题。</p>
<p>换句话说，如果一个NP完全问题可以在多项式时间内解决，那么所有的NP问题都可以在多项式时间内解决。因此，NP完全问题被认为是NP问题中最难的问题。</p>
<h3 id="P-vs-NP问题"><a href="#P-vs-NP问题" class="headerlink" title="P vs NP问题"></a>P vs NP问题</h3><p>P与NP问题是计算复杂性理论中的一个核心问题，问的是：P类问题和NP类问题是否相等？即，是否所有的NP问题都可以在多项式时间内通过确定性算法解决？这个问题至今尚未解决，是计算机科学中的一个重要未解难题。如果证明P = NP，则意味着所有NP问题都有高效的确定性算法；如果证明P ≠ NP，则意味着某些NP问题没有高效的确定性算法。</p>
<h1 id="高等数学"><a href="#高等数学" class="headerlink" title="高等数学"></a>高等数学</h1><h2 id="可导、可微、可积与连续的关系？"><a href="#可导、可微、可积与连续的关系？" class="headerlink" title="可导、可微、可积与连续的关系？"></a>可导、可微、可积与连续的关系？</h2><h3 id="一元函数"><a href="#一元函数" class="headerlink" title="一元函数"></a>一元函数</h3><p>可导等价可微</p>
<p>可导一定连续，连续不一定可导</p>
<p>连续一定可积，可积不一定连续</p>
<p>可导一定可积，可积不一定可导</p>
<h3 id="多元函数"><a href="#多元函数" class="headerlink" title="多元函数"></a>多元函数</h3><p>多元的可导只保证在x和y两个方向上可导</p>
<p>连续不一定可导，可导也不一定连续</p>
<p>可导不一定可微，可微一定可导</p>
<p>连续不一定可微，可微一定连续</p>
<p>偏导连续一定可微，可微不一定偏导连续</p>
<h2 id="方向导数是什么？"><a href="#方向导数是什么？" class="headerlink" title="方向导数是什么？"></a>方向导数是什么？</h2><p>多元函数沿某一个方向上的导数</p>
<p>二元函数除了x y两个偏导之外，还有很多其他方向的导数</p>
<img src="/2024/07/01/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E9%9D%A2%E7%BB%8F/20160506173846627.png" class="" title="img">

<h2 id="梯度及其物理意义？"><a href="#梯度及其物理意义？" class="headerlink" title="梯度及其物理意义？"></a>梯度及其物理意义？</h2><p>梯度是一个向量，既有大小也有方向</p>
<p>梯度的方向就是函数f在这点变化最快的方向；梯度的大小就是函数f在这点方向导数的最大值</p>
<p>（x偏导，y偏导）</p>
<h2 id="傅里叶级数与傅里叶变换之间的关系是什么？"><a href="#傅里叶级数与傅里叶变换之间的关系是什么？" class="headerlink" title="傅里叶级数与傅里叶变换之间的关系是什么？"></a>傅里叶级数与傅里叶变换之间的关系是什么？</h2><p>傅里叶级数是傅立叶变换的一种特殊情况。当一个周期为T的函数被表示为傅里叶级数时，其傅立叶变换是一个离散的频谱，只包含一系列离散的频率分量。</p>
<p>对于一个连续非周期函数，傅立叶变换将其表示为一个连续的频谱，包含了所有可能的频率分量。这相当于将傅里叶级数中的频率分量离散化为连续的频谱。</p>
<p>傅立叶变换可以视为傅里叶级数的极限情况，当周期趋向于无穷大时，傅里叶级数的频率间隔趋向于零，从而得到了连续的频谱。</p>
<h1 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h1><h2 id="什么是向量范数？矩阵范数？"><a href="#什么是向量范数？矩阵范数？" class="headerlink" title="什么是向量范数？矩阵范数？"></a>什么是向量范数？矩阵范数？</h2><p>向量范数（Vector Norm）是数学中用于测量向量大小或长度的函数。向量范数赋予向量一个非负的实数值，满足以下几个条件：</p>
<p><strong>非负性</strong>：对于任何向量 ( $\mathbf{v}$ )，范数 ($ |\mathbf{v}| \geq 0$ )，且 ($ |\mathbf{v}| = 0$ ) 当且仅当 ($ \mathbf{v} $) 是零向量。</p>
<p><strong>齐次性</strong>：对于任何标量 ($ \alpha$ ) 和向量 ( $\mathbf{v} $)，范数 ( $|\alpha \mathbf{v}| = |\alpha| |\mathbf{v}| $)。</p>
<p><strong>三角不等式</strong>：对于任何向量 ($ \mathbf{u} $) 和 ( $\mathbf{v}$ )，范数 ($ |\mathbf{u} + \mathbf{v}| \leq |\mathbf{u}| + |\mathbf{v}|$ )。</p>
<p>常见的向量范数有以下几种：</p>
<p><strong>1范数</strong><br>$$<br>|\mathbf{v}|<em>1 = \sum</em>{i=1}^{n} |v_i|,<br> \mathbf{v} = [v_1, v_2, \ldots, v_n]<br>$$<br><strong>2范数</strong><br>$$<br>|\mathbf{v}|<em>2 = \sqrt{\sum</em>{i=1}^{n} v_i^2}<br>$$<br><strong>p范数</strong>：<br>$$<br>|\mathbf{v}|<em>p = \left( \sum</em>{i=1}^{n} |v_i|^p \right)^{1/p}<br>$$<br>当 p = 1时，它是1范数；当p = 2时，它是2范数</p>
<p><strong>无穷范</strong><br>$$<br>|\mathbf{v}|<em>\infty = \max</em>{1 \leq i \leq n} |v_i|<br>$$<br>矩阵的范数（Matrix Norm）是对矩阵大小或长度的一种度量，类似于向量范数。</p>
<p>常用的矩阵范数包括以下几种：</p>
<p><strong>F范数</strong><br>$$<br>|A|<em>F = \sqrt{\sum</em>{i=1}^{m} \sum_{j=1}^{n} |a_{ij}|^2}<br>$$<br><strong>1 范数</strong><br>$$<br>|A|<em>1 = \max</em>{1 \leq j \leq n} \sum_{i=1}^{m} |a_{ij}|<br>$$</p>
<p>这是矩阵各列元素绝对值之和的最大值</p>
<p><strong>无穷范数</strong><br>$$<br>|A|<em>\infty = \max</em>{1 \leq i \leq m} \sum_{j=1}^{n} |a_{ij}|<br>$$</p>
<p>这是矩阵各行元素绝对值之和的最大值</p>
<p><strong>谱范数（2-范数）</strong><br>$$<br>|A|<em>2 = \sigma</em>{\max}(A)<br>$$</p>
<p>其中，$\sigma_{\max}(A) $是矩阵 AAA 的最大奇异值。奇异值是对称矩阵$A^TA$非负平方根的特征值。谱范数等于单位向量下矩阵的最大放大因子。</p>
<p><strong>p范数</strong><br>$$<br>|A|<em>p = \sup</em>{|x|_p = 1} |Ax|_p<br>$$</p>
<h2 id="线性方程组解的条件？"><a href="#线性方程组解的条件？" class="headerlink" title="线性方程组解的条件？"></a>线性方程组解的条件？</h2><h3 id="线性方程组解的条件"><a href="#线性方程组解的条件" class="headerlink" title="线性方程组解的条件"></a>线性方程组解的条件</h3><p>线性方程组的解的条件可以通过矩阵的行列式和秩来确定。一个线性方程组可以表示为矩阵方程 $AX=b$，其中 $A $是系数矩阵，$X $是未知向量，$b$是常数向量</p>
<h4 id="唯一解的条件"><a href="#唯一解的条件" class="headerlink" title="唯一解的条件"></a>唯一解的条件</h4><ul>
<li>系数矩阵$A$的秩等于增广矩阵$(A,b)$的秩，且等于n。</li>
</ul>
<h4 id="无解的条件"><a href="#无解的条件" class="headerlink" title="无解的条件"></a>无解的条件</h4><ul>
<li>系数矩阵$A$的秩小于增广矩阵$(A,b)$的秩。</li>
</ul>
<h4 id="无穷多解的条件"><a href="#无穷多解的条件" class="headerlink" title="无穷多解的条件"></a>无穷多解的条件</h4><ul>
<li>系数矩阵$A$的秩等于增广矩阵$(A,b)$的秩，但小于$n $</li>
</ul>
<h2 id="什么是标准正交基？施密特正交化？"><a href="#什么是标准正交基？施密特正交化？" class="headerlink" title="什么是标准正交基？施密特正交化？"></a>什么是标准正交基？施密特正交化？</h2><p>是一组相互正交且单位长度的向量，满足正交性，任意两两点乘为0</p>
<p>满足单位性，任一向量的模为1</p>
<p>施密特正交化是将一组线性无关的向量转化为一组正交向量的方法。</p>
<h2 id="什么是可逆矩阵？"><a href="#什么是可逆矩阵？" class="headerlink" title="什么是可逆矩阵？"></a>什么是可逆矩阵？</h2><p>可逆矩阵，也称为非奇异矩阵，是一个方阵。即存在一个矩阵$A^{-1}$，使得：</p>
<p>$$<br>A A^{-1} = A^{-1} A = E<br>$$<br>充要条件为行列式不等于0</p>
<h2 id="什么是矩阵的秩？"><a href="#什么是矩阵的秩？" class="headerlink" title="什么是矩阵的秩？"></a>什么是矩阵的秩？</h2><p>线性方程组中有用的方程个数；</p>
<p>极大线性无关组的个数；</p>
<h2 id="什么是矩阵的迹？"><a href="#什么是矩阵的迹？" class="headerlink" title="什么是矩阵的迹？"></a>什么是矩阵的迹？</h2><p>主对角线元素的和</p>
<h2 id="什么是正定矩阵？"><a href="#什么是正定矩阵？" class="headerlink" title="什么是正定矩阵？"></a>什么是正定矩阵？</h2><p>若矩阵A为n阶方阵，并且它的二次型恒大于0，则A为正定矩阵</p>
<h2 id="行列式的本质？"><a href="#行列式的本质？" class="headerlink" title="行列式的本质？"></a>行列式的本质？</h2><p>在二维空间中，一个矩阵对应于一个线性变换，行列式的绝对值表示该变换如何缩放面积。行列式的绝对值表示缩放的倍数。</p>
<h2 id="如何判断线性相关、线性无关？"><a href="#如何判断线性相关、线性无关？" class="headerlink" title="如何判断线性相关、线性无关？"></a>如何判断线性相关、线性无关？</h2><p>一组向量$A={a_1,a_2,a_3…，a_m}$，该组向量构成的矩阵的秩$rank&lt;m$，线性相关。若$rank=m$那么线性无关。</p>
<h2 id="什么是线性变换？什么是线性空间？"><a href="#什么是线性变换？什么是线性空间？" class="headerlink" title="什么是线性变换？什么是线性空间？"></a>什么是线性变换？什么是线性空间？</h2><h3 id="线性变换"><a href="#线性变换" class="headerlink" title="线性变换"></a>线性变换</h3><p>线性变换是线性代数中的一个基本概念，它指的是从一个向量空间到另一个向量空间的映射，并且这种映射满足线性性。具体来说，设有两个向量空间 $ V $ 和 $ W $ 以及一个映射 $T: V \to W$，如果对于任意的 $\mathbf{u}, \mathbf{v} \in V $和标量 $c$，这个映射 $T$ 满足以下两个条件：</p>
<ol>
<li><strong>加法封闭性</strong>：$ T(\mathbf{u} + \mathbf{v}) = T(\mathbf{u}) + T(\mathbf{v})$</li>
<li><strong>数乘封闭性</strong>：$T(c\mathbf{u}) = cT(\mathbf{u})$</li>
</ol>
<p>那么，$T$就称为一个线性变换。</p>
<h3 id="线性空间"><a href="#线性空间" class="headerlink" title="线性空间"></a>线性空间</h3><img src="/2024/07/01/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E9%9D%A2%E7%BB%8F/image-20240703203825126.png" class="" title="image-20240703203825126">

<h2 id="极大线性无关组是什么？"><a href="#极大线性无关组是什么？" class="headerlink" title="极大线性无关组是什么？"></a>极大线性无关组是什么？</h2><img src="/2024/07/01/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E9%9D%A2%E7%BB%8F/image-20240703172235255.png" class="" title="image-20240703172235255">

<h2 id="什么是矩阵相似？什么是矩阵合同？1"><a href="#什么是矩阵相似？什么是矩阵合同？1" class="headerlink" title="什么是矩阵相似？什么是矩阵合同？1"></a>什么是矩阵相似？什么是矩阵合同？1</h2><img src="/2024/07/01/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E9%9D%A2%E7%BB%8F/image-20240703172518012.png" class="" title="image-20240703172518012">

<img src="/2024/07/01/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E9%9D%A2%E7%BB%8F/image-20240703172620336.png" class="" title="image-20240703172620336">

<img src="/2024/07/01/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E9%9D%A2%E7%BB%8F/image-20240703172630137.png" class="" title="image-20240703172630137">

<h2 id="特征值-特征向量？如何计算？有何意义？"><a href="#特征值-特征向量？如何计算？有何意义？" class="headerlink" title="特征值 特征向量？如何计算？有何意义？"></a>特征值 特征向量？如何计算？有何意义？</h2><p><strong>特征值和特征向量</strong>是线性代数中的重要概念，尤其在矩阵分析、微分方程和数据分析中具有广泛应用。</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li><strong>特征值</strong>: 对于一个给定的方阵A，如果存在一个非零向量$\mathbf{v}$和一个标量$\lambda$，使得 $A \mathbf{v} = \lambda \mathbf{v}，$那么 $\lambda$ 就被称为矩阵$A$的特征值。</li>
<li><strong>特征向量</strong> : 满足上述方程的非零向量$\mathbf{v}$就被称为对应于特征值$\lambda$的特征向量。</li>
</ul>
<h3 id="计算方法"><a href="#计算方法" class="headerlink" title="计算方法"></a>计算方法</h3><p><strong>特征值</strong>：</p>
<ul>
<li><p>从方程$A \mathbf{v} = \lambda \mathbf{v}$出发，可以重写为$(A - \lambda I) \mathbf{v} = 0$，其中$I$是单位矩阵。</p>
</li>
<li><p>要求这个方程有非零解，矩阵$(A - \lambda I)$必须是奇异矩阵（即行列式为零）<br>$$<br>\det(A - \lambda I) = 0<br>$$</p>
</li>
<li><p>这个行列式方程是关于$\lambda$的多项式方程，其解就是矩阵$A$的特征值。</p>
</li>
</ul>
<p><strong>特征向量</strong>：</p>
<ul>
<li>对于每个特征值$ \lambda$，代入方程$(A - \lambda I) \mathbf{v} = 0$。</li>
<li>求解这个齐次线性方程组，得到对应的特征向量。</li>
</ul>
<p><strong>意义：</strong></p>
<p>在图像处理领域，特征值和特征向量用于边缘检测、模式识别和图像压缩等任务。例如，在边缘检测中，图像梯度的特征值和特征向量可以帮助识别图像中的边缘和轮廓。</p>
<p>在自然语言处理任务中，特征值和特征向量用于词嵌入和文档表示。例如，LSA（潜在语义分析）通过SVD分解词-文档矩阵来发现词汇和文档之间的潜在语义关系。</p>
<h1 id="概率论与数理统计"><a href="#概率论与数理统计" class="headerlink" title="概率论与数理统计"></a>概率论与数理统计</h1><h2 id="大数定理？"><a href="#大数定理？" class="headerlink" title="大数定理？"></a>大数定理？</h2><p>样本均值依概率收敛于期望</p>
<p>切比雪夫大数定理：相互独立的随机变量序列，方差存在且都有上界，则<strong>变量的均值</strong>依概率收敛于<strong>它们数学期望的均值</strong></p>
<p>辛勤大数定理：相互独立、<strong>服从同一分布</strong>的随机变量序列，具有数学期望，则<strong>变量的均值</strong>依概率收敛于它们数学期望的均值<strong>（由于是同一分布，所以其实就是数学期望$\mu$）</strong></p>
<p>伯努利大数定理：实验次数n很大时，可以用频率来替代概率。</p>
<img src="/2024/07/01/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E9%9D%A2%E7%BB%8F/image-20240703191038247.png" class="" title="image-20240703191038247">

<h2 id="中心极限定理？"><a href="#中心极限定理？" class="headerlink" title="中心极限定理？"></a>中心极限定理？</h2><p>依分布收敛</p>
<p>指的是在一定条件下，随机变量个数比较多时相互独立的随机变量之和近似服从正态分布。</p>
<p>独立同分布的变量序列，有方差和期望，它们的和依分布收敛于正态分布</p>
<p>服从二项分布的变量序列$X_n$，个数很多时，收敛于正态分布</p>
<h2 id="条件概率公式？"><a href="#条件概率公式？" class="headerlink" title="条件概率公式？"></a>条件概率公式？</h2><img src="/2024/07/01/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E9%9D%A2%E7%BB%8F/image-20240703191536674.png" class="" title="image-20240703191536674">

<h2 id="全概率公式的意义？"><a href="#全概率公式的意义？" class="headerlink" title="全概率公式的意义？"></a>全概率公式的意义？</h2><img src="/2024/07/01/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E9%9D%A2%E7%BB%8F/image-20240703191633278.png" class="" title="image-20240703191633278">

<h2 id="贝叶斯公式？"><a href="#贝叶斯公式？" class="headerlink" title="贝叶斯公式？"></a>贝叶斯公式？</h2><img src="/2024/07/01/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E9%9D%A2%E7%BB%8F/image-20240703191659842.png" class="" title="image-20240703191659842">

<h2 id="伯努利试验？"><a href="#伯努利试验？" class="headerlink" title="伯努利试验？"></a>伯努利试验？</h2><p>每次试验仅有两个对立的结果$A、\bar{A}$，独立重复试验，这样的实验就是伯努利试验。</p>
<p>其中n次独立重复试验中时间A出现的次数的概率计算满足$B(n,p)$，为二项分布</p>
<h2 id="极大似然估计"><a href="#极大似然估计" class="headerlink" title="极大似然估计"></a>极大似然估计</h2><h2 id="其他重要的定理"><a href="#其他重要的定理" class="headerlink" title="其他重要的定理"></a>其他重要的定理</h2><p>不相关不一定独立，独立一定不相关。（相关指的是相关系数为0，但是相关系数其实反映的只是线性相关而已）</p>
<p>相关系数：<br>$$<br>p(XY)=\frac{Cov(X,Y)}{\sqrt{D(x)D(y)}}<br>$$</p>
<p>两个正态分布的随机变量之和不一定是正态分布的，如果他们两个相互独立的话，是正态分布的。</p>
<p>对于两个标准正态分布，不相关等价于独立</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Endorphin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/07/01/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E9%9D%A2%E7%BB%8F/">http://example.com/2024/07/01/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E9%9D%A2%E7%BB%8F/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Endorphin's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a><a class="post-meta__tags" href="/tags/%E5%A4%8F%E4%BB%A4%E8%90%A5/">夏令营</a></div><div class="post_share"><div class="social-share" data-image="https://tse4-mm.cn.bing.net/th/id/OIP-C.WRUHUqRfulfxFQ8Z3GihKQAAAA?w=202&amp;h=202&amp;c=7&amp;r=0&amp;o=5&amp;dpr=1.3&amp;pid=1.7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer=""></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2024/06/24/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E7%BC%96%E7%A8%8B%E5%B0%8F%E8%AE%B0/" title="编程小记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">编程小记</div></div></a></div></nav><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://tse4-mm.cn.bing.net/th/id/OIP-C.WRUHUqRfulfxFQ8Z3GihKQAAAA?w=202&amp;h=202&amp;c=7&amp;r=0&amp;o=5&amp;dpr=1.3&amp;pid=1.7" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"></div><div class="author-info__name">Endorphin</div><div class="author-info__description">An IT Student</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/EndorphinFluoxetine"><i class="fab fa-github"></i><span>Github</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/EndorphinFluoxetine" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:dongzhencs@nwafu.edu.cn" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">If you have any suggestion, welcome to contact me!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">计算机组成原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BA%BF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">总线是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFDMA%EF%BC%9F"><span class="toc-number">1.2.</span> <span class="toc-text">什么是DMA？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4CPU"><span class="toc-number">1.3.</span> <span class="toc-text">简述五级流水CPU</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E5%8D%95%E6%9D%A1%E6%8C%87%E4%BB%A4%E6%97%B6%E5%8D%95%E5%91%A8%E6%9C%9FCPU%E5%92%8C%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4CPU%E8%B0%81%E6%9B%B4%E5%BF%AB%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.4.</span> <span class="toc-text">执行单条指令时单周期CPU和五级流水CPU谁更快，为什么？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E6%8E%92%E5%BA%8F"><span class="toc-number">2.1.</span> <span class="toc-text">内部排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%B1%82%E7%A8%B3%E5%AE%9A%E6%80%A7%EF%BC%9F"><span class="toc-number">2.2.</span> <span class="toc-text">排序为什么要求稳定性？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%83%9C%E8%80%85%E6%A0%91"><span class="toc-number">2.3.</span> <span class="toc-text">胜者树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%A5%E8%80%85%E6%A0%91"><span class="toc-number">2.4.</span> <span class="toc-text">败者树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E8%B4%A5%E8%80%85%E6%A0%91%E4%B8%8D%E7%94%A8%E8%83%9C%E8%80%85%E6%A0%91%EF%BC%9F"><span class="toc-number">2.5.</span> <span class="toc-text">外部排序为什么不用多路归并？为什么用败者树不用胜者树？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">2.6.</span> <span class="toc-text">二叉搜索树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AVL%E6%A0%91"><span class="toc-number">2.7.</span> <span class="toc-text">AVL树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AVL%E5%B9%B3%E8%A1%A1%E6%A0%91%E6%97%8B%E8%BD%AC%EF%BC%8C%E4%BB%8E%E4%B8%80%E4%B8%AA%E7%8A%B6%E6%80%81%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E6%95%B0%E6%97%B6%EF%BC%8C%E6%9C%80%E5%A4%9A%E6%97%8B%E8%BD%AC%E5%87%A0%E6%AC%A1%EF%BC%9F"><span class="toc-number">2.8.</span> <span class="toc-text">AVL平衡树旋转，从一个状态插入、删除一个数时，最多旋转几次？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-number">2.9.</span> <span class="toc-text">红黑树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#B-%E6%A0%91"><span class="toc-number">2.10.</span> <span class="toc-text">B+树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#B%E6%A0%91%EF%BC%88B-%E6%A0%91%EF%BC%89"><span class="toc-number">2.11.</span> <span class="toc-text">B树（B-树）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E4%BA%86%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BF%98%E4%BC%9A%E5%87%BA%E7%8E%B0B-%E3%80%81B-%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91%E5%91%A2%EF%BC%9F"><span class="toc-number">2.12.</span> <span class="toc-text">为什么有了平衡二叉树还会出现B-、B+、红黑树呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E7%94%A8B-%E6%A0%91%E8%80%8C%E4%B8%8D%E7%94%A8B-%E6%A0%91%EF%BC%9F"><span class="toc-number">2.13.</span> <span class="toc-text">为什么数据库索引用B+树而不用B-树？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.14.</span> <span class="toc-text">线索二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%8F%8A%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="toc-number">2.15.</span> <span class="toc-text">哈夫曼树及哈夫曼编码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%8C%E8%AF%81%E6%98%8E%E4%BA%8C%E5%BA%A6%E8%8A%82%E7%82%B9%E6%95%B0%E4%B8%8E%E9%9B%B6%E5%BA%A6%E8%8A%82%E7%82%B9%E6%95%B0%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">2.16.</span> <span class="toc-text">二叉树，证明二度节点数与零度节点数的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">2.17.</span> <span class="toc-text">最小生成树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%AE%97%E6%B3%95%E8%AF%81%E6%98%8E%E4%B8%80%E4%B8%AA%E9%93%BE%E6%98%AF%E5%9B%9E%E6%96%87%E9%93%BE%EF%BC%8C%E4%BD%BF%E5%BE%97%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%BAO-n-%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%BAO-1"><span class="toc-number">2.18.</span> <span class="toc-text">设计一个算法证明一个链是回文链，使得时间复杂度为O(n)空间复杂度为O(1)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95"><span class="toc-number">2.19.</span> <span class="toc-text">最短路径算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-number">2.20.</span> <span class="toc-text">拓扑排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84"><span class="toc-number">2.21.</span> <span class="toc-text">关键路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DFS-BFS"><span class="toc-number">2.22.</span> <span class="toc-text">DFS/BFS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%BC%96%E7%A8%8B%E5%88%A4%E6%96%AD%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.23.</span> <span class="toc-text">如何编程判断一棵二叉树是完全二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">2.24.</span> <span class="toc-text">并查集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%A3%E5%88%97%E8%A1%A8"><span class="toc-number">2.25.</span> <span class="toc-text">散列表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#KMP"><span class="toc-number">2.26.</span> <span class="toc-text">KMP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E3%80%81%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="toc-number">2.27.</span> <span class="toc-text">时间复杂度、空间复杂度的计算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">2.28.</span> <span class="toc-text">0-1背包问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#P%E9%97%AE%E9%A2%98-NP%E9%97%AE%E9%A2%98-NP%E5%AE%8C%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">2.29.</span> <span class="toc-text">P问题 NP问题 NP完全问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#P%E9%97%AE%E9%A2%98"><span class="toc-number">2.29.1.</span> <span class="toc-text">P问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NP%E9%97%AE%E9%A2%98"><span class="toc-number">2.29.2.</span> <span class="toc-text">NP问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NP%E5%AE%8C%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">2.29.3.</span> <span class="toc-text">NP完全问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#P-vs-NP%E9%97%AE%E9%A2%98"><span class="toc-number">2.29.4.</span> <span class="toc-text">P vs NP问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6"><span class="toc-number">3.</span> <span class="toc-text">高等数学</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E5%AF%BC%E3%80%81%E5%8F%AF%E5%BE%AE%E3%80%81%E5%8F%AF%E7%A7%AF%E4%B8%8E%E8%BF%9E%E7%BB%AD%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-number">3.1.</span> <span class="toc-text">可导、可微、可积与连续的关系？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0"><span class="toc-number">3.1.1.</span> <span class="toc-text">一元函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0"><span class="toc-number">3.1.2.</span> <span class="toc-text">多元函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E5%90%91%E5%AF%BC%E6%95%B0%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.2.</span> <span class="toc-text">方向导数是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A2%AF%E5%BA%A6%E5%8F%8A%E5%85%B6%E7%89%A9%E7%90%86%E6%84%8F%E4%B9%89%EF%BC%9F"><span class="toc-number">3.3.</span> <span class="toc-text">梯度及其物理意义？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%82%85%E9%87%8C%E5%8F%B6%E7%BA%A7%E6%95%B0%E4%B8%8E%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.4.</span> <span class="toc-text">傅里叶级数与傅里叶变换之间的关系是什么？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0"><span class="toc-number">4.</span> <span class="toc-text">线性代数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%90%91%E9%87%8F%E8%8C%83%E6%95%B0%EF%BC%9F%E7%9F%A9%E9%98%B5%E8%8C%83%E6%95%B0%EF%BC%9F"><span class="toc-number">4.1.</span> <span class="toc-text">什么是向量范数？矩阵范数？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E8%A7%A3%E7%9A%84%E6%9D%A1%E4%BB%B6%EF%BC%9F"><span class="toc-number">4.2.</span> <span class="toc-text">线性方程组解的条件？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E8%A7%A3%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="toc-number">4.2.1.</span> <span class="toc-text">线性方程组解的条件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%94%AF%E4%B8%80%E8%A7%A3%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="toc-number">4.2.1.1.</span> <span class="toc-text">唯一解的条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E8%A7%A3%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="toc-number">4.2.1.2.</span> <span class="toc-text">无解的条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E7%A9%B7%E5%A4%9A%E8%A7%A3%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="toc-number">4.2.1.3.</span> <span class="toc-text">无穷多解的条件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%A0%87%E5%87%86%E6%AD%A3%E4%BA%A4%E5%9F%BA%EF%BC%9F%E6%96%BD%E5%AF%86%E7%89%B9%E6%AD%A3%E4%BA%A4%E5%8C%96%EF%BC%9F"><span class="toc-number">4.3.</span> <span class="toc-text">什么是标准正交基？施密特正交化？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%AF%E9%80%86%E7%9F%A9%E9%98%B5%EF%BC%9F"><span class="toc-number">4.4.</span> <span class="toc-text">什么是可逆矩阵？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%9F%A9%E9%98%B5%E7%9A%84%E7%A7%A9%EF%BC%9F"><span class="toc-number">4.5.</span> <span class="toc-text">什么是矩阵的秩？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%9F%A9%E9%98%B5%E7%9A%84%E8%BF%B9%EF%BC%9F"><span class="toc-number">4.6.</span> <span class="toc-text">什么是矩阵的迹？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%A3%E5%AE%9A%E7%9F%A9%E9%98%B5%EF%BC%9F"><span class="toc-number">4.7.</span> <span class="toc-text">什么是正定矩阵？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%8C%E5%88%97%E5%BC%8F%E7%9A%84%E6%9C%AC%E8%B4%A8%EF%BC%9F"><span class="toc-number">4.8.</span> <span class="toc-text">行列式的本质？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E7%BA%BF%E6%80%A7%E7%9B%B8%E5%85%B3%E3%80%81%E7%BA%BF%E6%80%A7%E6%97%A0%E5%85%B3%EF%BC%9F"><span class="toc-number">4.9.</span> <span class="toc-text">如何判断线性相关、线性无关？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E6%80%A7%E7%A9%BA%E9%97%B4%EF%BC%9F"><span class="toc-number">4.10.</span> <span class="toc-text">什么是线性变换？什么是线性空间？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2"><span class="toc-number">4.10.1.</span> <span class="toc-text">线性变换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E7%A9%BA%E9%97%B4"><span class="toc-number">4.10.2.</span> <span class="toc-text">线性空间</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%81%E5%A4%A7%E7%BA%BF%E6%80%A7%E6%97%A0%E5%85%B3%E7%BB%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.11.</span> <span class="toc-text">极大线性无关组是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%9F%A9%E9%98%B5%E7%9B%B8%E4%BC%BC%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E7%9F%A9%E9%98%B5%E5%90%88%E5%90%8C%EF%BC%9F1"><span class="toc-number">4.12.</span> <span class="toc-text">什么是矩阵相似？什么是矩阵合同？1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E5%BE%81%E5%80%BC-%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F%EF%BC%9F%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%EF%BC%9F%E6%9C%89%E4%BD%95%E6%84%8F%E4%B9%89%EF%BC%9F"><span class="toc-number">4.13.</span> <span class="toc-text">特征值 特征向量？如何计算？有何意义？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">4.13.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95"><span class="toc-number">4.13.2.</span> <span class="toc-text">计算方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1"><span class="toc-number">5.</span> <span class="toc-text">概率论与数理统计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A7%E6%95%B0%E5%AE%9A%E7%90%86%EF%BC%9F"><span class="toc-number">5.1.</span> <span class="toc-text">大数定理？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E5%BF%83%E6%9E%81%E9%99%90%E5%AE%9A%E7%90%86%EF%BC%9F"><span class="toc-number">5.2.</span> <span class="toc-text">中心极限定理？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E6%A6%82%E7%8E%87%E5%85%AC%E5%BC%8F%EF%BC%9F"><span class="toc-number">5.3.</span> <span class="toc-text">条件概率公式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E6%A6%82%E7%8E%87%E5%85%AC%E5%BC%8F%E7%9A%84%E6%84%8F%E4%B9%89%EF%BC%9F"><span class="toc-number">5.4.</span> <span class="toc-text">全概率公式的意义？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%85%AC%E5%BC%8F%EF%BC%9F"><span class="toc-number">5.5.</span> <span class="toc-text">贝叶斯公式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%AF%E5%8A%AA%E5%88%A9%E8%AF%95%E9%AA%8C%EF%BC%9F"><span class="toc-number">5.6.</span> <span class="toc-text">伯努利试验？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%81%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1"><span class="toc-number">5.7.</span> <span class="toc-text">极大似然估计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E9%87%8D%E8%A6%81%E7%9A%84%E5%AE%9A%E7%90%86"><span class="toc-number">5.8.</span> <span class="toc-text">其他重要的定理</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/01/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E9%9D%A2%E7%BB%8F/" title="夏令营面试准备">夏令营面试准备</a><time datetime="2024-06-30T16:00:00.000Z" title="发表于 2024-07-01 00:00:00">2024-07-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/24/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E7%BC%96%E7%A8%8B%E5%B0%8F%E8%AE%B0/" title="编程小记">编程小记</a><time datetime="2024-06-23T16:00:00.000Z" title="发表于 2024-06-24 00:00:00">2024-06-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/15/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E8%AE%A1%E7%BD%91%E5%AE%9E%E8%AE%AD%E8%AE%BA%E6%96%87/" title="计算机网络综合训练报告">计算机网络综合训练报告</a><time datetime="2024-06-14T16:00:00.000Z" title="发表于 2024-06-15 00:00:00">2024-06-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/03/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/YOLOv9%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/" title="YOLOv9">YOLOv9</a><time datetime="2024-06-02T16:00:00.000Z" title="发表于 2024-06-03 00:00:00">2024-06-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/28/My-first-blog/" title="My first blog">My first blog</a><time datetime="2024-05-28T08:38:37.271Z" title="发表于 2024-05-28 16:38:37">2024-05-28</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">©2020 - 2024 By Endorphin</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo-endorphins-projects.vercel.app/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo-endorphins-projects.vercel.app/',
      region: '',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))

    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(init,0)
    else getScript('https://cdn.jsdelivr.net/npm/twikoo@1.6.31/dist/twikoo.all.min.js').then(init)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>